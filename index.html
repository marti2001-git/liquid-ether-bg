<!doctype html>
<html lang="en">
  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width,initial-scale=1" />
    <title>Liquid Ether BG</title>

    <style>
      html, body {
        margin: 0;
        height: 100%;
        background: transparent;
        overflow: hidden;
      }
      #root {
        position: fixed;
        inset: 0;
        width: 100vw;
        height: 100vh;
        overflow: hidden;
        touch-action: none;
        pointer-events: none; /* keeps Wix UI clickable */
        background: transparent;
      }
      canvas { display:block; width:100%; height:100%; }
    </style>

    <script src="https://unpkg.com/three@0.159.0/build/three.min.js"></script>
  </head>

  <body>
    <div id="root"></div>

    <script>
      (function () {
        const root = document.getElementById("root");

        // ---- QUICK CONFIG (edit freely) ----
        const OPTS = {
          mouseForce: 50,
          cursorSize: 300,
          isViscous: true,
          viscous: 100,
          iterationsViscous: 32,
          iterationsPoisson: 32,
          dt: 0.014,
          BFECC: true,
          resolution: 0.5,
          isBounce: true,
          colors: ["#8db4ff", "#8db4ff", "#bcbcbe"],
          autoDemo: false
        };

        // Reduced motion safeguard
        const reduced = window.matchMedia && window.matchMedia("(prefers-reduced-motion: reduce)").matches;
        if (reduced) {
          OPTS.autoDemo = false;
          OPTS.mouseForce = Math.min(OPTS.mouseForce, 15);
          OPTS.resolution = Math.min(OPTS.resolution, 0.35);
        }

        function makePaletteTexture(stops) {
          let arr = Array.isArray(stops) && stops.length ? stops : ["#fff", "#fff"];
          if (arr.length === 1) arr = [arr[0], arr[0]];
          const w = arr.length;
          const data = new Uint8Array(w * 4);
          for (let i = 0; i < w; i++) {
            const c = new THREE.Color(arr[i]);
            data[i*4+0] = Math.round(c.r * 255);
            data[i*4+1] = Math.round(c.g * 255);
            data[i*4+2] = Math.round(c.b * 255);
            data[i*4+3] = 255;
          }
          const tex = new THREE.DataTexture(data, w, 1, THREE.RGBAFormat);
          tex.magFilter = THREE.LinearFilter;
          tex.minFilter = THREE.LinearFilter;
          tex.wrapS = THREE.ClampToEdgeWrapping;
          tex.wrapT = THREE.ClampToEdgeWrapping;
          tex.generateMipmaps = false;
          tex.needsUpdate = true;
          return tex;
        }

        const paletteTex = makePaletteTexture(OPTS.colors);
        const bgVec4 = new THREE.Vector4(0.0196, 0.0314, 0.0863, 1.0);


        const face_vert = `
          attribute vec3 position;
          uniform vec2 px;
          uniform vec2 boundarySpace;
          varying vec2 uv;
          precision highp float;
          void main(){
            vec3 pos = position;
            vec2 scale = 1.0 - boundarySpace * 2.0;
            pos.xy = pos.xy * scale;
            uv = vec2(0.5)+(pos.xy)*0.5;
            gl_Position = vec4(pos, 1.0);
          }
        `;

        const line_vert = `
          attribute vec3 position;
          uniform vec2 px;
          precision highp float;
          varying vec2 uv;
          void main(){
            vec3 pos = position;
            uv = 0.5 + pos.xy * 0.5;
            vec2 n = sign(pos.xy);
            pos.xy = abs(pos.xy) - px * 1.0;
            pos.xy *= n;
            gl_Position = vec4(pos, 1.0);
          }
        `;

        const mouse_vert = `
          precision highp float;
          attribute vec3 position;
          attribute vec2 uv;
          uniform vec2 center;
          uniform vec2 scale;
          uniform vec2 px;
          varying vec2 vUv;
          void main(){
            vec2 pos = position.xy * scale * 2.0 * px + center;
            vUv = uv;
            gl_Position = vec4(pos, 0.0, 1.0);
          }
        `;

        const advection_frag = `
          precision highp float;
          uniform sampler2D velocity;
          uniform float dt;
          uniform bool isBFECC;
          uniform vec2 fboSize;
          uniform vec2 px;
          varying vec2 uv;
          void main(){
            vec2 ratio = max(fboSize.x, fboSize.y) / fboSize;
            if(isBFECC == false){
              vec2 vel = texture2D(velocity, uv).xy;
              vec2 uv2 = uv - vel * dt * ratio;
              vec2 newVel = texture2D(velocity, uv2).xy;
              gl_FragColor = vec4(newVel, 0.0, 0.0);
            } else {
              vec2 spot_new = uv;
              vec2 vel_old = texture2D(velocity, uv).xy;
              vec2 spot_old = spot_new - vel_old * dt * ratio;
              vec2 vel_new1 = texture2D(velocity, spot_old).xy;
              vec2 spot_new2 = spot_old + vel_new1 * dt * ratio;
              vec2 error = spot_new2 - spot_new;
              vec2 spot_new3 = spot_new - error / 2.0;
              vec2 vel_2 = texture2D(velocity, spot_new3).xy;
              vec2 spot_old2 = spot_new3 - vel_2 * dt * ratio;
              vec2 newVel2 = texture2D(velocity, spot_old2).xy; 
              gl_FragColor = vec4(newVel2, 0.0, 0.0);
            }
          }
        `;

        const color_frag = `
          precision highp float;
          uniform sampler2D velocity;
          uniform sampler2D palette;
          uniform vec4 bgColor;
          varying vec2 uv;
          void main(){
            vec2 vel = texture2D(velocity, uv).xy;
            float lenv = clamp(length(vel), 0.0, 1.0);
            vec3 c = texture2D(palette, vec2(lenv, 0.5)).rgb;
            vec3 outRGB = mix(bgColor.rgb, c, lenv);
            float outA = mix(bgColor.a, 1.0, lenv);
            gl_FragColor = vec4(outRGB, outA);
          }
        `;

        const divergence_frag = `
          precision highp float;
          uniform sampler2D velocity;
          uniform float dt;
          uniform vec2 px;
          varying vec2 uv;
          void main(){
            float x0 = texture2D(velocity, uv-vec2(px.x, 0.0)).x;
            float x1 = texture2D(velocity, uv+vec2(px.x, 0.0)).x;
            float y0 = texture2D(velocity, uv-vec2(0.0, px.y)).y;
            float y1 = texture2D(velocity, uv+vec2(0.0, px.y)).y;
            float divergence = (x1 - x0 + y1 - y0) / 2.0;
            gl_FragColor = vec4(divergence / dt);
          }
        `;

        const externalForce_frag = `
          precision highp float;
          uniform vec2 force;
          uniform vec2 center;
          uniform vec2 scale;
          uniform vec2 px;
          varying vec2 vUv;
          void main(){
            vec2 circle = (vUv - 0.5) * 2.0;
            float d = 1.0 - min(length(circle), 1.0);
            d *= d;
            gl_FragColor = vec4(force * d, 0.0, 1.0);
          }
        `;

        const poisson_frag = `
          precision highp float;
          uniform sampler2D pressure;
          uniform sampler2D divergence;
          uniform vec2 px;
          varying vec2 uv;
          void main(){
            float p0 = texture2D(pressure, uv + vec2(px.x * 2.0, 0.0)).r;
            float p1 = texture2D(pressure, uv - vec2(px.x * 2.0, 0.0)).r;
            float p2 = texture2D(pressure, uv + vec2(0.0, px.y * 2.0)).r;
            float p3 = texture2D(pressure, uv - vec2(0.0, px.y * 2.0)).r;
            float div = texture2D(divergence, uv).r;
            float newP = (p0 + p1 + p2 + p3) / 4.0 - div;
            gl_FragColor = vec4(newP);
          }
        `;

        const pressure_frag = `
          precision highp float;
          uniform sampler2D pressure;
          uniform sampler2D velocity;
          uniform vec2 px;
          uniform float dt;
          varying vec2 uv;
          void main(){
            float step = 1.0;
            float p0 = texture2D(pressure, uv + vec2(px.x * step, 0.0)).r;
            float p1 = texture2D(pressure, uv - vec2(px.x * step, 0.0)).r;
            float p2 = texture2D(pressure, uv + vec2(0.0, px.y * step)).r;
            float p3 = texture2D(pressure, uv - vec2(0.0, px.y * step)).r;
            vec2 v = texture2D(velocity, uv).xy;
            vec2 gradP = vec2(p0 - p1, p2 - p3) * 0.5;
            v = v - gradP * dt;
            gl_FragColor = vec4(v, 0.0, 1.0);
          }
        `;

        const viscous_frag = `
          precision highp float;
          uniform sampler2D velocity;
          uniform sampler2D velocity_new;
          uniform float v;
          uniform vec2 px;
          uniform float dt;
          varying vec2 uv;
          void main(){
            vec2 old = texture2D(velocity, uv).xy;
            vec2 new0 = texture2D(velocity_new, uv + vec2(px.x * 2.0, 0.0)).xy;
            vec2 new1 = texture2D(velocity_new, uv - vec2(px.x * 2.0, 0.0)).xy;
            vec2 new2 = texture2D(velocity_new, uv + vec2(0.0, px.y * 2.0)).xy;
            vec2 new3 = texture2D(velocity_new, uv - vec2(0.0, px.y * 2.0)).xy;
            vec2 newv = 4.0 * old + v * dt * (new0 + new1 + new2 + new3);
            newv /= 4.0 * (1.0 + v * dt);
            gl_FragColor = vec4(newv, 0.0, 0.0);
          }
        `;

        class CommonClass {
          constructor(){ this.width=0; this.height=0; this.container=null; this.renderer=null; this.clock=null; }
          init(container){
            this.container = container;
            this.resize();
            this.renderer = new THREE.WebGLRenderer({ antialias:true, alpha:true });
            this.renderer.autoClear = false;
            this.renderer.setClearColor(new THREE.Color(0x000000), 0);
            this.renderer.setPixelRatio(Math.min(window.devicePixelRatio || 1, 2));
            this.renderer.setSize(this.width, this.height);
            this.renderer.domElement.style.width="100%";
            this.renderer.domElement.style.height="100%";
            this.clock = new THREE.Clock(); this.clock.start();
          }
          resize(){
            const r = this.container.getBoundingClientRect();
            this.width = Math.max(1, Math.floor(r.width));
            this.height = Math.max(1, Math.floor(r.height));
            if (this.renderer) this.renderer.setSize(this.width, this.height, false);
          }
          update(){ this.clock.getDelta(); }
        }

        class MouseClass {
          constructor(){
            this.coords = new THREE.Vector2(0,0);
            this.coords_old = new THREE.Vector2(0,0);
            this.diff = new THREE.Vector2(0,0);
            // --- ORBIT (always-on motion) ---
            this.user = new THREE.Vector2(0, 0);       // last real pointer coords (-1..1)
            this.lastInteract = performance.now()- 999999;      // last time user moved
            this.orbit = new THREE.Vector2(0, 0);       // virtual pointer
            this.orbitSpeed = 0.085;                     // 0.06–0.14
            this.orbitAmp = 0.82;                       // 0.75–0.95
            this.orbitResumeDelay = 400;                // ms before orbit takes over
            this.orbitRamp = 1200;                       // ms blend duration
            this.container = null;
            this.isHoverInside = false;
            this._mm = (e)=>this.onMove(e.clientX,e.clientY);
            this._tm = (e)=>{ if(e.touches&&e.touches[0]) this.onMove(e.touches[0].clientX,e.touches[0].clientY); };
          }
          init(container){
            this.container = container;
            window.addEventListener("mousemove", this._mm, { passive:true });
            window.addEventListener("touchmove", this._tm, { passive:true });
          }
          onMove(x,y){
            const r = this.container.getBoundingClientRect();
            this.isHoverInside = x>=r.left && x<=r.right && y>=r.top && y<=r.bottom;
            if(!this.isHoverInside) return;
            const nx = (x - r.left) / r.width;
            const ny = (y - r.top) / r.height;
            this.coords.set(nx*2-1, -(ny*2-1));
            this.user.copy(this.coords);
            this.lastInteract = performance.now();
          }
          update(){
            const now = performance.now();
            const t = now * 0.001 * this.orbitSpeed;
          
            // Lissajous smooth (no jerks)
            this.orbit.set(
              Math.sin(t * 1.0) * this.orbitAmp,
              Math.cos(t * 1.3) * this.orbitAmp
            );
          
            // blend orbit in when user is idle
            const idleMs = now - this.lastInteract;
            let blend = 0;
            if (idleMs > this.orbitResumeDelay) {
              blend = Math.min(1, (idleMs - this.orbitResumeDelay) / this.orbitRamp);
              // smoothstep
              blend = blend * blend * (3 - 2 * blend);
            }
          
            // coords = lerp(user -> orbit)
            this.coords.copy(this.user).lerp(this.orbit, blend);
          
            // diff for injecting force
            this.diff.subVectors(this.coords, this.coords_old);
            this.coords_old.copy(this.coords);
          
            // safety
            if (this.coords_old.x === 0 && this.coords_old.y === 0) this.diff.set(0,0);
          }
        class ShaderPass {
          constructor(Common, props){
            this.Common = Common;
            this.props = props || {};
            this.uniforms = this.props.material?.uniforms;
            this.scene = new THREE.Scene();
            this.camera = new THREE.Camera();
            if(this.uniforms){
              this.material = new THREE.RawShaderMaterial(this.props.material);
              this.plane = new THREE.Mesh(new THREE.PlaneGeometry(2,2), this.material);
              this.scene.add(this.plane);
            }
          }
          update(){
            this.Common.renderer.setRenderTarget(this.props.output || null);
            this.Common.renderer.render(this.scene, this.camera);
            this.Common.renderer.setRenderTarget(null);
          }
        }

        class Advection extends ShaderPass {
          constructor(Common, simProps){
            super(Common, {
              material: {
                vertexShader: face_vert,
                fragmentShader: advection_frag,
                uniforms: {
                  boundarySpace: { value: simProps.cellScale },
                  px: { value: simProps.cellScale },
                  fboSize: { value: simProps.fboSize },
                  velocity: { value: simProps.src.texture },
                  dt: { value: simProps.dt },
                  isBFECC: { value: true }
                }
              },
              output: simProps.dst
            });
            const boundaryG = new THREE.BufferGeometry();
            boundaryG.setAttribute("position", new THREE.BufferAttribute(new Float32Array([
              -1,-1,0,-1,1,0,-1,1,0,1,1,0,1,1,0,1,-1,0,1,-1,0,-1,-1,0
            ]), 3));
            const boundaryM = new THREE.RawShaderMaterial({
              vertexShader: line_vert,
              fragmentShader: advection_frag,
              uniforms: this.uniforms
            });
            this.line = new THREE.LineSegments(boundaryG, boundaryM);
            this.scene.add(this.line);
          }
          run({dt,isBounce,BFECC}){
            this.uniforms.dt.value = dt;
            this.uniforms.isBFECC.value = BFECC;
            this.line.visible = isBounce;
            super.update();
          }
        }

        class ExternalForce extends ShaderPass {
          constructor(Common, Mouse, simProps){
            super(Common, { output: simProps.dst });
            this.Mouse = Mouse;
            const mouseM = new THREE.RawShaderMaterial({
              vertexShader: mouse_vert,
              fragmentShader: externalForce_frag,
              blending: THREE.AdditiveBlending,
              depthWrite: false,
              uniforms: {
                px: { value: simProps.cellScale },
                force: { value: new THREE.Vector2(0,0) },
                center: { value: new THREE.Vector2(0,0) },
                scale: { value: new THREE.Vector2(simProps.cursor_size, simProps.cursor_size) }
              }
            });
            this.mouse = new THREE.Mesh(new THREE.PlaneGeometry(1,1), mouseM);
            this.scene.add(this.mouse);
          }
          run(props){
            const Mouse = this.Mouse;
            const fx = (Mouse.diff.x / 2) * props.mouse_force;
            const fy = (Mouse.diff.y / 2) * props.mouse_force;

            const csx = props.cursor_size * props.cellScale.x;
            const csy = props.cursor_size * props.cellScale.y;

            const cx = Math.min(Math.max(Mouse.coords.x, -1 + csx + props.cellScale.x*2), 1 - csx - props.cellScale.x*2);
            const cy = Math.min(Math.max(Mouse.coords.y, -1 + csy + props.cellScale.y*2), 1 - csy - props.cellScale.y*2);

            const u = this.mouse.material.uniforms;
            u.force.value.set(fx, fy);
            u.center.value.set(cx, cy);
            u.scale.value.set(props.cursor_size, props.cursor_size);
            super.update();
          }
        }

        class Viscous extends ShaderPass {
          constructor(Common, simProps){
            super(Common, {
              material: {
                vertexShader: face_vert,
                fragmentShader: viscous_frag,
                uniforms: {
                  boundarySpace: { value: simProps.boundarySpace },
                  velocity: { value: simProps.src.texture },
                  velocity_new: { value: simProps.dst_.texture },
                  v: { value: simProps.viscous },
                  px: { value: simProps.cellScale },
                  dt: { value: simProps.dt }
                }
              },
              output: simProps.dst
            });
            this.output0 = simProps.dst_;
            this.output1 = simProps.dst;
          }
          run({viscous,iterations,dt}){
            let fbo_in, fbo_out;
            this.uniforms.v.value = viscous;
            for(let i=0;i<iterations;i++){
              if(i%2===0){ fbo_in=this.output0; fbo_out=this.output1; }
              else{ fbo_in=this.output1; fbo_out=this.output0; }
              this.uniforms.velocity_new.value = fbo_in.texture;
              this.props.output = fbo_out;
              this.uniforms.dt.value = dt;
              super.update();
            }
            return fbo_out;
          }
        }

        class Divergence extends ShaderPass {
          constructor(Common, simProps){
            super(Common, {
              material: {
                vertexShader: face_vert,
                fragmentShader: divergence_frag,
                uniforms: {
                  boundarySpace: { value: simProps.boundarySpace },
                  velocity: { value: simProps.src.texture },
                  px: { value: simProps.cellScale },
                  dt: { value: simProps.dt }
                }
              },
              output: simProps.dst
            });
          }
          run({vel}){
            this.uniforms.velocity.value = vel.texture;
            super.update();
          }
        }

        class Poisson extends ShaderPass {
          constructor(Common, simProps){
            super(Common, {
              material: {
                vertexShader: face_vert,
                fragmentShader: poisson_frag,
                uniforms: {
                  boundarySpace: { value: simProps.boundarySpace },
                  pressure: { value: simProps.dst_.texture },
                  divergence: { value: simProps.src.texture },
                  px: { value: simProps.cellScale }
                }
              },
              output: simProps.dst
            });
            this.output0 = simProps.dst_;
            this.output1 = simProps.dst;
          }
          run({iterations}){
            let p_in, p_out;
            for(let i=0;i<iterations;i++){
              if(i%2===0){ p_in=this.output0; p_out=this.output1; }
              else{ p_in=this.output1; p_out=this.output0; }
              this.uniforms.pressure.value = p_in.texture;
              this.props.output = p_out;
              super.update();
            }
            return p_out;
          }
        }

        class Pressure extends ShaderPass {
          constructor(Common, simProps){
            super(Common, {
              material: {
                vertexShader: face_vert,
                fragmentShader: pressure_frag,
                uniforms: {
                  boundarySpace: { value: simProps.boundarySpace },
                  pressure: { value: simProps.src_p.texture },
                  velocity: { value: simProps.src_v.texture },
                  px: { value: simProps.cellScale },
                  dt: { value: simProps.dt }
                }
              },
              output: simProps.dst
            });
          }
          run({vel,pressure}){
            this.uniforms.velocity.value = vel.texture;
            this.uniforms.pressure.value = pressure.texture;
            super.update();
          }
        }

        class Simulation {
          constructor(Common, Mouse, options){
            this.Common = Common;
            this.Mouse = Mouse;
            this.options = Object.assign({
              iterations_poisson: 32,
              iterations_viscous: 32,
              mouse_force: 20,
              resolution: 0.5,
              cursor_size: 100,
              viscous: 30,
              isBounce: false,
              dt: 0.014,
              isViscous: false,
              BFECC: true
            }, options);

            this.fboSize = new THREE.Vector2();
            this.cellScale = new THREE.Vector2();
            this.boundarySpace = new THREE.Vector2();
            this.fbos = {};
            this.init();
          }

          getFloatType(){
            const isIOS = /(iPad|iPhone|iPod)/i.test(navigator.userAgent);
            return isIOS ? THREE.HalfFloatType : THREE.FloatType;
          }

          calcSize(){
            const w = Math.max(1, Math.round(this.options.resolution * this.Common.width));
            const h = Math.max(1, Math.round(this.options.resolution * this.Common.height));
            this.fboSize.set(w,h);
            this.cellScale.set(1/w, 1/h);
          }

          mkRT(){
            const type = this.getFloatType();
            return new THREE.WebGLRenderTarget(this.fboSize.x, this.fboSize.y, {
              type,
              depthBuffer:false,
              stencilBuffer:false,
              minFilter: THREE.LinearFilter,
              magFilter: THREE.LinearFilter,
              wrapS: THREE.ClampToEdgeWrapping,
              wrapT: THREE.ClampToEdgeWrapping
            });
          }

          init(){
            this.calcSize();
            this.fbos.vel_0 = this.mkRT();
            this.fbos.vel_1 = this.mkRT();
            this.fbos.vel_viscous0 = this.mkRT();
            this.fbos.vel_viscous1 = this.mkRT();
            this.fbos.div = this.mkRT();
            this.fbos.pressure_0 = this.mkRT();
            this.fbos.pressure_1 = this.mkRT();

            this.advection = new Advection(this.Common, {
              cellScale: this.cellScale,
              fboSize: this.fboSize,
              dt: this.options.dt,
              src: this.fbos.vel_0,
              dst: this.fbos.vel_1
            });

            this.externalForce = new ExternalForce(this.Common, this.Mouse, {
              cellScale: this.cellScale,
              cursor_size: this.options.cursor_size,
              dst: this.fbos.vel_1
            });

            this.viscousPass = new Viscous(this.Common, {
              cellScale: this.cellScale,
              boundarySpace: this.boundarySpace,
              viscous: this.options.viscous,
              src: this.fbos.vel_1,
              dst: this.fbos.vel_viscous1,
              dst_: this.fbos.vel_viscous0,
              dt: this.options.dt
            });

            this.divergence = new Divergence(this.Common, {
              cellScale: this.cellScale,
              boundarySpace: this.boundarySpace,
              src: this.fbos.vel_viscous0,
              dst: this.fbos.div,
              dt: this.options.dt
            });

            this.poisson = new Poisson(this.Common, {
              cellScale: this.cellScale,
              boundarySpace: this.boundarySpace,
              src: this.fbos.div,
              dst: this.fbos.pressure_1,
              dst_: this.fbos.pressure_0
            });

            this.pressure = new Pressure(this.Common, {
              cellScale: this.cellScale,
              boundarySpace: this.boundarySpace,
              src_p: this.fbos.pressure_0,
              src_v: this.fbos.vel_viscous0,
              dst: this.fbos.vel_0,
              dt: this.options.dt
            });
          }

          resize(){
            this.calcSize();
            for(const k in this.fbos) this.fbos[k].setSize(this.fboSize.x, this.fboSize.y);
          }

          update(){
            this.boundarySpace.copy(this.options.isBounce ? new THREE.Vector2(0,0) : this.cellScale);

            this.advection.run({ dt:this.options.dt, isBounce:this.options.isBounce, BFECC:this.options.BFECC });

            this.externalForce.run({
              cursor_size: this.options.cursor_size,
              mouse_force: this.options.mouse_force,
              cellScale: this.cellScale
            });

            let vel = this.fbos.vel_1;
            if(this.options.isViscous){
              vel = this.viscousPass.run({
                viscous: this.options.viscous,
                iterations: this.options.iterations_viscous,
                dt: this.options.dt
              });
            }

            this.divergence.run({ vel });
            const pressure = this.poisson.run({ iterations: this.options.iterations_poisson });
            this.pressure.run({ vel, pressure });
          }
        }

        class Output {
          constructor(Common, Mouse, simOptions){
            this.Common = Common;
            this.simulation = new Simulation(Common, Mouse, simOptions);
            this.scene = new THREE.Scene();
            this.camera = new THREE.Camera();
            this.mesh = new THREE.Mesh(new THREE.PlaneGeometry(2,2),
              new THREE.RawShaderMaterial({
                vertexShader: face_vert,
                fragmentShader: color_frag,
                transparent: true,
                depthWrite: false,
                uniforms: {
                  velocity: { value: this.simulation.fbos.vel_0.texture },
                  boundarySpace: { value: new THREE.Vector2() },
                  palette: { value: paletteTex },
                  bgColor: { value: bgVec4 }
                }
              })
            );
            this.scene.add(this.mesh);
          }
          resize(){ this.simulation.resize(); }
          update(){
            this.simulation.update();
            this.Common.renderer.setRenderTarget(null);
            this.Common.renderer.render(this.scene, this.camera);
          }
        }

        const Common = new CommonClass();
        const Mouse = new MouseClass();
        Common.init(root);
        Mouse.init(root);

        root.prepend(Common.renderer.domElement);

        const output = new Output(Common, Mouse, {
          iterations_poisson: OPTS.iterationsPoisson,
          iterations_viscous: OPTS.iterationsViscous,
          mouse_force: OPTS.mouseForce,
          resolution: OPTS.resolution,
          cursor_size: OPTS.cursorSize,
          viscous: OPTS.viscous,
          isBounce: OPTS.isBounce,
          dt: OPTS.dt,
          isViscous: OPTS.isViscous,
          BFECC: OPTS.BFECC
        });

        let raf = null;
        function loop(){
          Common.update();
          Mouse.update();
          output.update();
          raf = requestAnimationFrame(loop);
        }
        loop();

        let resizeRaf = null;
        window.addEventListener("resize", () => {
          if (resizeRaf) cancelAnimationFrame(resizeRaf);
          resizeRaf = requestAnimationFrame(() => {
            Common.resize();
            output.resize();
          });
        });

        document.addEventListener("visibilitychange", () => {
          if (document.hidden) {
            if (raf) cancelAnimationFrame(raf);
            raf = null;
          } else if (!raf) {
            loop();
          }
        });
      })();
    </script>
  </body>
</html>

